import cv2
import numpy as np
import pyautogui
import display
from scipy import stats

# Set the region of interest (ROI) coordinates for capturing the game window
# Adjust these coordinates to match the position of the Tiny Wings game window on your screen
# The format is (left, top, width, height)
game_window_roi = (0, 0, 950, 550)
#display.make_window(game_window_roi)

# Set the parameters for hill detection and bird tracking
hill_threshold = 100  # Adjust this threshold based on the hills' visual characteristics
max_outlier_distance = 50
bird_template_path = 'bird.png'  # Path to the template image of the bird

# Load the bird template image
bird_template = cv2.imread(bird_template_path, 0)  # Load the image in grayscale
# Set the interval for generating points along the hills curve
point_interval = 10  # Adjust this value based on the desired density of the hill points

while True:
    # Capture the game window screenshot
    screenshot = pyautogui.screenshot(region=game_window_roi)
    screenshot = np.array(screenshot)
    
    # Preprocess the screenshot
    # Perform any necessary preprocessing steps like cropping, resizing, or color space conversions
    
    # Perform hill detection
    gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)



    _, binary = cv2.threshold(gray, hill_threshold, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Process the detected contours and extract the hill points
    hill_points = []
    for contour in contours:
        # Process each contour and generate points along the curve
        perimeter = cv2.arcLength(contour, True)
        approx_curve = cv2.approxPolyDP(contour, 0.01 * perimeter, True)
        
        # Generate points along the curve at the specified interval
        for i in range(0, len(approx_curve), point_interval):
            point = approx_curve[i][0]
            hill_points.append(point)


    # hill_points = []
    # for contour in contours:
    #     # Process each contour and generate points along the curve
    #     perimeter = cv2.arcLength(contour, True)
    #     approx_curve = cv2.approxPolyDP(contour, 0.005 * perimeter, True)

    #     # Generate points along the curve at the specified interval
    #     for i in range(0, len(approx_curve), point_interval):
    #         point = approx_curve[i][0]
    #         hill_points.append(point)

    # hill_points = np.array(hill_points)

    # # Calculate the Z-scores for each coordinate separately
    # z_scores = stats.zscore(hill_points, axis=0)

    # # Set a threshold to define what constitutes an outlier
    # threshold = 3.0

    # # Find the indices of the non-outlier points based on the threshold
    # non_outlier_indices = np.all(np.abs(z_scores) < threshold, axis=1)
    # #print("HERE\n\n\n")
    # #print(non_outlier_indices)
    # # Filter out the outlier points
    # filtered_hill_points = hill_points[non_outlier_indices]

    ### MORE EFFICIENT BUT WORSE
 
    # # Apply edge detection
    # edges = cv2.Canny(gray, 50, 150)

    # # Apply Hough line transform to detect lines representing the hills
    # lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=50, minLineLength=50, maxLineGap=10)

    # # Extract the points along the hill curve from the detected lines
    # hill_points = []
    # if lines is not None:
    #     for line in lines:
    #         x1, y1, x2, y2 = line[0]
    #         # Generate points along the line at the specified interval
    #         for x in range(x1, x2, point_interval):
    #             y = int((y2-y1)/(x2-x1)*(x-x1) + y1)
    #             hill_points.append((x, y))        
    
    
    # Perform bird tracking
    bird_position = None
    # Use template matching or other techniques to locate the bird in the screenshot
    
    # Print the bird position and hill points
    #print("Bird Position:", bird_position)
    #print("Hill Points:", hill_points)
    #print("FILTERED:", filtered_hill_points)
    display.visualize_points(game_window_roi, bird_position, hill_points)
    # Update the RL model with the extracted hill and bird information
    
    # Your RL model logic goes here
    
    # Exit the loop when the game is over or based on a specific condition
    
    # Break the loop for demonstration purposes
    cv2.waitKey(8)

# Clean up any resources used (e.g., release OpenCV windows, etc.)
cv2.destroyAllWindows()


















import cv2
import numpy as np
import pyautogui
import display
import keyboard
import time
from scipy.interpolate import splprep, splev

# Set the region of interest (ROI) coordinates for capturing the game window
# Adjust these coordinates to match the position of the Tiny Wings game window on your screen
# The format is (left, top, width, height)
left, top, width, height = 0, 50, 900, 600
game_window_roi = (left, top, width, height)
#display.make_window(game_window_roi)

height_threshold = height * 0.2
hill_threshold = 220  # Adjust this threshold based on the hills' visual characteristics

# Set the parameters for hill detection and bird tracking
bird_template_path = 'bird.png'  # Path to the template image of the bird
bird_template = cv2.imread(bird_template_path, 0)  # Load the image in grayscale


while True:
    # Capture the game window screenshot
    screenshot = pyautogui.screenshot(region=game_window_roi)
    screenshot = np.array(screenshot)
    
    # Preprocess the screenshot
    # Perform any necessary preprocessing steps like cropping, resizing, or color space conversions
    
    # Perform hill detection
    gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)
    _, binary = cv2.threshold(gray, hill_threshold, 255, cv2.THRESH_BINARY)
    contours, hierarchy = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    hill_coordinates = [(i, height) for i in range(width)]
    
    for contour in contours:
        # Add the contour points to the hill coordinates
        for point in contour:
            x, y = point[0]
            if y > height_threshold and hill_coordinates[x][1] > y:
                hill_coordinates[x] = (x, y)
    
    # Extract x and y coordinates from the hill points
    x_coords, y_coords = zip(*hill_coordinates)
    
    # Perform spline interpolation to generate additional points along the curve
    tck, u = splprep([x_coords, y_coords], s=0, per=False)
    new_u = np.linspace(0, 1, num=width)
    interpolated_points = splev(new_u, tck)
    interpolated_points = np.round(interpolated_points).astype(int)
    interpolated_hill_coordinates = list(zip(interpolated_points[0], interpolated_points[1]))
    
    # Replace the points in hill_coordinates that are not following the line well with interpolated points
    for i, (x, y) in enumerate(hill_coordinates):
        if y - interpolated_hill_coordinates[x][1] > 10:  # Adjust the threshold as needed
            hill_coordinates[i] = interpolated_hill_coordinates[x]
    
    bird_position = None
    
    display.visualize_points(game_window_roi, bird_position, hill_coordinates)
    
    cv2.waitKey(800)

# Clean up any resources used (e.g., release OpenCV windows, etc.)
cv2.destroyAllWindows()




















import cv2
import numpy as np
import pyautogui
import display
import keyboard
import time
from scipy.interpolate import interp1d

# Set the region of interest (ROI) coordinates for capturing the game window
# Adjust these coordinates to match the position of the Tiny Wings game window on your screen
# The format is (left, top, width, height)
left, top, width, height = 0, 50, 900, 600
game_window_roi = (left, top, width, height)
#display.make_window(game_window_roi)

height_threshold = height * 0.2
hill_threshold = 220  # Adjust this threshold based on the hills' visual characteristics

# Set the parameters for hill detection and bird tracking
bird_template_path = 'bird.png'  # Path to the template image of the bird
bird_template = cv2.imread(bird_template_path, 0)  # Load the image in grayscale


while True:
    # Capture the game window screenshot
    screenshot = pyautogui.screenshot(region=game_window_roi)
    screenshot = np.array(screenshot)
    
    # Preprocess the screenshot
    # Perform any necessary preprocessing steps like cropping, resizing, or color space conversions
    
    # Perform hill detection
    gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)
    _, binary = cv2.threshold(gray, hill_threshold, 255, cv2.THRESH_BINARY)
    contours, hierarchy = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    hill_coordinates = [(i, height) for i in range(width)]
    
    for contour in contours:
        # Add the contour points to the hill coordinates
        for point in contour:
            x, y = point[0]
            if y > height_threshold and hill_coordinates[x][1] > y:
                hill_coordinates[x] = (x, y)
    
    # Extract x and y coordinates from the hill points
    x_coords, y_coords = zip(*hill_coordinates)
    
    # Perform polynomial curve fitting
    degree = 5  # Adjust the degree of the polynomial as needed
    poly_coeffs = np.polyfit(x_coords, y_coords, degree)
    poly_func = np.poly1d(poly_coeffs)
    
    # Generate interpolated points along the curve using the polynomial function
    interpolated_x = np.linspace(min(x_coords), max(x_coords), width)
    interpolated_y = poly_func(interpolated_x)
    interpolated_hill_coordinates = list(zip(interpolated_x.astype(int), interpolated_y.astype(int)))
    
    # Replace the points in hill_coordinates that are not following the line well with interpolated points
    for i, (x, y) in enumerate(hill_coordinates):
        if y - interpolated_hill_coordinates[x][1] > 10:  # Adjust the threshold as needed
            hill_coordinates[i] = interpolated_hill_coordinates[x]
    
    bird_position = None
    
    display.visualize_points(game_window_roi, bird_position, hill_coordinates)
    
    cv2.waitKey(800)

# Clean up any resources used (e.g., release OpenCV windows, etc.)
cv2.destroyAllWindows()


